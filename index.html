<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Stacking Puzzle with Logos</title>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.js"></script>
<style>
  html,body {margin:0;padding:0;background:#222;height:100%;display:flex;justify-content:center;align-items:center;}
  #gameContainer {width:95%;height:95%;}
</style>
</head>
<body>
<div id="gameContainer"></div>
<script>
const GAME_TIME = 60;

const config = {
  type: Phaser.AUTO,
  parent: 'gameContainer',
  backgroundColor: '#4174cf',
  scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH, width: 800, height: 1200 },
  physics: {
    default: 'matter',
    matter: { gravity: { y: 1 }, debug: false }
  },
  scene: { preload, create, update, resize }
};

new Phaser.Game(config);

function preload() {
  // replace these URLs with your own images
  this.load.image('frame', 'frame.png');
  this.load.image('exitBtn', 'ExitButton.png');   // sample exit icon
  this.load.image('resetBtn', 'ResetButton.png');  // sample refresh icon
  this.load.image('logo1', 'QIBLogo.png'); // sample
  this.load.image('logo2', 'QIBJunior.png'); // sample
}

function create() {
  const scene = this;
  scene.score = 0;
  scene.timeLeft = GAME_TIME;
  scene.gameOver = false;

  const w = scene.scale.width;
  const h = scene.scale.height;
  const padding = Math.min(w,h) * 0.03;
  const paletteHeight = h * 0.15;
  const playTop = padding + paletteHeight + 20;

  // Background frame
  const frame = scene.add.image(w/2, h/2, 'frame');
  frame.displayWidth = w;
  frame.displayHeight = h;

  // Exit & Reset image buttons
  const btnSize = 48;
  const exitBtn = scene.add.image(padding + btnSize/2, padding + btnSize/2, 'exitBtn')
                  .setDisplaySize(btnSize, btnSize).setInteractive();
  exitBtn.on('pointerdown', ()=> window.location.href = 'about:blank');

  const resetBtn = scene.add.image(w - padding - btnSize/2, padding + btnSize/2, 'resetBtn')
                  .setDisplaySize(btnSize, btnSize).setInteractive();
  resetBtn.on('pointerdown', ()=> scene.scene.restart());

  // Score & Timer
  scene.scoreText = scene.add.text(padding + 10, playTop, "Score: 0",
      { fontSize: '24px', fontFamily: 'Arial', color: '#ffffff' }).setOrigin(0,0);
  scene.timeText = scene.add.text(w - padding - 10, playTop, "Time: " + GAME_TIME,
      { fontSize: '24px', fontFamily: 'Arial', color: '#ffffff' }).setOrigin(1,0);

  // Shape palette with equal gaps
  const paletteGroup = scene.add.group();
  const sizes = [
    { w: w*0.15, h: paletteHeight*0.4 },
    { w: w*0.10, h: paletteHeight*0.5 },
    { w: w*0.18, h: paletteHeight*0.35 },
    { w: w*0.12, h: paletteHeight*0.45 },
    { w: w*0.14, h: paletteHeight*0.4 }
  ];
  const totalShapesWidth = sizes.reduce((sum, s) => sum + s.w, 0);
  const gap = (w - padding*2 - totalShapesWidth) / (sizes.length + 1);
  let currentX = padding + gap;
  const centerY = padding + paletteHeight/2;
  let draggingClone = null;

  sizes.forEach(s => {
    const x = currentX + s.w/2;
    const shape = scene.add.rectangle(x, centerY, s.w, s.h, 0x374d9d)
      .setStrokeStyle(2, 0xffffff)
      .setInteractive();
    paletteGroup.add(shape);

    shape.on('pointerdown', pointer => {
      if (scene.gameOver) return;
      if (draggingClone) draggingClone.destroy();
      draggingClone = scene.add.rectangle(pointer.x, pointer.y, s.w, s.h, 0x374d9d)
        .setStrokeStyle(2,0xffffff);
    });

    currentX += s.w + gap;
  });

  scene.input.on('pointermove', pointer => {
    if (draggingClone) draggingClone.setPosition(pointer.x, pointer.y);
  });
  scene.input.on('pointerup', pointer => {
    if (!draggingClone) return;
    if (pointer.y > playTop + 40 && pointer.y < h - padding - 20) {
      scene.matter.add.gameObject(draggingClone, { shape:'rectangle', chamfer:4 })
        .setBounce(0.1)
        .setFriction(0.3);
      scene.score++;
      scene.scoreText.setText("Score: " + scene.score);
    } else {
      draggingClone.destroy();
    }
    draggingClone = null;
  });

  // Ground platform
  const groundY = h - padding - 40;
  const ground = scene.matter.add.rectangle(w/2, groundY, w*0.75, 40, { isStatic:true });
  scene.add.rectangle(w/2, groundY, w*0.75, 40, 0x11182a);

  // Bottom Logos
  const logoSize = 64;
  scene.add.image(padding + logoSize/2, h - padding - logoSize/2, 'logo1')
       .setDisplaySize(logoSize, logoSize);
  scene.add.image(w - padding - logoSize/2, h - padding - logoSize/2, 'logo2')
       .setDisplaySize(logoSize, logoSize);

  // Timer countdown
  scene.time.addEvent({
    delay: 1000,
    loop: true,
    callback: () => {
      if (scene.gameOver) return;
      scene.timeLeft--;
      scene.timeText.setText("Time: " + scene.timeLeft);
      if (scene.timeLeft <= 0) {
        scene.gameOver = true;
        scene.add.text(w/2, h/2, "GAME OVER",
          { fontSize: '48px', fontFamily: 'Arial', color: '#ff0000' }).setOrigin(0.5);
      }
    }
  });
}

function update() {}
function resize(gameSize) { this.cameras.resize(gameSize.width, gameSize.height); }
</script>
</body>
</html>
