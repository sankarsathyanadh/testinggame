<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Stacking Puzzle</title>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.js"></script>
<style>
  html,body {
    margin:0; padding:0; background:#222;
    width:100%; height:100%;
    display:flex; justify-content:center; align-items:center;
  }
  #gameContainer {width:100%; height:100%;}
</style>
</head>
<body>
<div id="gameContainer"></div>
<script>
const GAME_TIME = 60;

const config = {
  type: Phaser.AUTO,
  parent: 'gameContainer',
  backgroundColor: '#4174cf',
  scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH, width: 800, height: 1200 },
  physics: {
    default: 'matter',
    matter: { gravity: { y: 1 }, debug: false }
  },
  scene: { preload, create, update }
};

new Phaser.Game(config);

function preload() {
  // replace these with your own images
   this.load.image('frame', 'frame.png');
  this.load.image('exitBtn', 'ExitButton.png');   // sample exit icon
  this.load.image('resetBtn', 'ResetButton.png');  // sample refresh icon
  this.load.image('logo1', 'QIBLogo.png'); // sample
  this.load.image('logo2', 'QIBJunior.png'); // sample
}

function create() {
  const scene = this;
  scene.score = 0;
  scene.timeLeft = GAME_TIME;
  scene.gameOver = false;

  const w = scene.scale.width;
  const h = scene.scale.height;

  // ----- FRAME -----
  const frame = scene.add.image(w/2, h/2, 'frame');
  frame.setDisplaySize(w, h); // always full screen

  // Add generous padding so UI sits well inside frame
  const padding = Math.min(w, h) * 0.08;

  const paletteHeight = h * 0.15;
  const uiTop = padding + 10;
  const playTop = padding + paletteHeight + 40;

  // ----- TOP BUTTONS -----
  const btnSize = 56;
  const exitBtn = scene.add.image(padding + btnSize/2, uiTop + btnSize/2, 'exitBtn')
                  .setDisplaySize(btnSize, btnSize).setInteractive();
  exitBtn.on('pointerdown', () => window.location.href = 'about:blank');

  const resetBtn = scene.add.image(w - padding - btnSize/2, uiTop + btnSize/2, 'resetBtn')
                  .setDisplaySize(btnSize, btnSize).setInteractive();
  resetBtn.on('pointerdown', () => scene.scene.restart());

  // ----- SCORE & TIMER -----
  scene.scoreText = scene.add.text(padding + 10, uiTop + btnSize + 10, 'Score: 0',
    { fontSize: '26px', fontFamily: 'Arial', color: '#ffffff' }).setOrigin(0,0);
  scene.timeText = scene.add.text(w - padding - 10, uiTop + btnSize + 10, 'Time: ' + GAME_TIME,
    { fontSize: '26px', fontFamily: 'Arial', color: '#ffffff' }).setOrigin(1,0);

  // ----- SHAPE PALETTE -----
  const sizes = [
    { w: w*0.15, h: paletteHeight*0.4 },
    { w: w*0.10, h: paletteHeight*0.5 },
    { w: w*0.18, h: paletteHeight*0.35 },
    { w: w*0.12, h: paletteHeight*0.45 },
    { w: w*0.14, h: paletteHeight*0.4 }
  ];
  const totalWidth = sizes.reduce((sum, s) => sum + s.w, 0);
  const gap = (w - 2*padding - totalWidth) / (sizes.length + 1);
  let xPos = padding + gap;
  const centerY = uiTop + btnSize + 20 + paletteHeight/2;
  let dragging = null;

  sizes.forEach(s => {
    const rect = scene.add.rectangle(xPos + s.w/2, centerY, s.w, s.h, 0x374d9d)
                  .setStrokeStyle(2,0xffffff).setInteractive();
    rect.on('pointerdown', pointer => {
      if (scene.gameOver) return;
      if (dragging) dragging.destroy();
      dragging = scene.add.rectangle(pointer.x, pointer.y, s.w, s.h, 0x374d9d)
                        .setStrokeStyle(2,0xffffff);
    });
    xPos += s.w + gap;
  });

  scene.input.on('pointermove', p => { if (dragging) dragging.setPosition(p.x, p.y); });
  scene.input.on('pointerup', p => {
    if (!dragging) return;
    if (p.y > playTop && p.y < h - padding) {
      scene.matter.add.gameObject(dragging, { shape:'rectangle' })
          .setBounce(0.1).setFriction(0.3);
      scene.score++;
      scene.scoreText.setText('Score: ' + scene.score);
    } else {
      dragging.destroy();
    }
    dragging = null;
  });

  // ----- GROUND -----
  const groundY = h - padding - 40;
  scene.matter.add.rectangle(w/2, groundY, w*0.75, 40, { isStatic:true });
  scene.add.rectangle(w/2, groundY, w*0.75, 40, 0x11182a);

  // ----- BOTTOM LOGOS (maintain aspect ratio) -----
  const logoSize = 70;
  const logo1 = scene.add.image(padding + logoSize/2, h - padding - logoSize/2, 'logo1');
  const logo2 = scene.add.image(w - padding - logoSize/2, h - padding - logoSize/2, 'logo2');
  [logo1, logo2].forEach(l => {
    l.setDisplaySize(logoSize, logoSize * (l.height / l.width)); // preserve aspect
  });

  // ----- TIMER -----
  scene.time.addEvent({
    delay: 1000,
    loop: true,
    callback: () => {
      if (scene.gameOver) return;
      scene.timeLeft--;
      scene.timeText.setText('Time: ' + scene.timeLeft);
      if (scene.timeLeft <= 0) {
        scene.gameOver = true;
        scene.add.text(w/2, h/2, 'GAME OVER',
          { fontSize: '48px', fontFamily: 'Arial', color: '#ff0000' }).setOrigin(0.5);
      }
    }
  });
}

function update() {}
</script>
</body>
</html>
